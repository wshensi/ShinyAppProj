{
  "hash": "9ba586085c741a5c14f073bbb93f5907",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Hands-on Exercise 8.3\"\ndescription: \"Visualising Geospatial Point Data\" \ndate: \"June 12, 2025\" \ndate-modified: \"June 13, 2025\" \nformat: html\nauthor: \"Wang Shen Si\" \neditor: visual \nexecute: \n  eval: true\n  echo: true\n  warning: false\n  freeze: true\n---\n\n\n\n## **Getting Started**\n\n### **Installing and loading packages**\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(tmap, tidyverse, sf)\n```\n:::\n\n\n\n### **Importing data**\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nNGA_wp <- read_rds(\"data/rds/NGA_wp.rds\")\n```\n:::\n\n\n\n## **Basic Choropleth Mapping**\n\n### **Visualising distribution of non-functional water point**\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np1 <- tm_shape(NGA_wp) +\n  tm_polygons(fill = \"wp_functional\",\n             fill.scale = tm_scale_intervals(\n               style = \"equal\",\n               n = 10,\n               values = \"brewer.blues\"),\n             fill.legend = tm_legend(\n               position = c(\"right\", \"bottom\"))) +\n  tm_borders(lwd = 0.1,\n             fill_alpha = 1) +\n  tm_title(\"Distribution of functional water point by LGAs\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\np2 <- tm_shape(NGA_wp) + \n  tm_polygons(fill = \"total_wp\", \n              fill.scale = tm_scale_intervals(\n                style = \"equal\",\n                n = 10,\n                values = \"brewer.blues\"),\n              fill.legend = tm_legend(\n                position = c(\"right\", \"bottom\"))) +\n  tm_borders(lwd = 0.1, \n             fill_alpha = 1) + \n  tm_title(\"Distribution of total  water point by LGAs\")\n```\n:::\n\n\n\n## **Choropleth Map for Rates**\n\n### **Deriving Proportion of Functional Water Points and Non-Functional Water Points**\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nNGA_wp <- NGA_wp %>%\n  mutate(pct_functional = wp_functional/total_wp) %>%\n  mutate(pct_nonfunctional = wp_nonfunctional/total_wp)\n```\n:::\n\n\n\n### **Plotting map of rate**\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(NGA_wp) +\n  tm_polygons(\"pct_functional\",\n              fill.scale = tm_scale_intervals(\n                style = \"equal\",\n                n = 10,\n                values = \"brewer.blues\"),\n              fill.legend = tm_legend(\n                position = c(\"right\", \"bottom\"))) + \n  tm_borders(lwd = 0.1,\n             fill_alpha = 1) +\n  tm_title(\"Rate map of functional water point by LGAs\")\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex08.3_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n\n## **Extreme Value Maps**\n\n### **Percentile Map**\n\nThe percentile map is a special type of quantile map with six specific categories: 0-1%,1-10%, 10-50%,50-90%,90-99%, and 99-100%. The corresponding breakpoints can be derived by means of the base R quantile command, passing an explicit vector of cumulative probabilities as c(0,.01,.1,.5,.9,.99,1). Note that the begin and endpoint need to be included.\n\n#### Data Preparation\n\nStep 1: Exclude records with NA by using the code chunk below.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nNGA_wp <- NGA_wp %>%\n  drop_na()\n```\n:::\n\n\n\nStep 2: Creating customised classification and extracting values\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npercent <- c(0,.01,.1,.5,.9,.99,1)\nvar <- NGA_wp[\"pct_functional\"] %>%\n  st_set_geometry(NULL)\nquantile(var[,1], percent)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       0%        1%       10%       50%       90%       99%      100% \n0.0000000 0.0000000 0.2169811 0.4791667 0.8611111 1.0000000 1.0000000 \n```\n\n\n:::\n:::\n\n\n\n#### Creating the get.var function\n\nFirstly, we will write an R function as shown below to extract a variable (i.e. *wp_nonfunctional*) as a vector out of an sf data.frame.\n\n-   arguments:\n\n    -   vname: variable name (as character, in quotes)\n\n    -   df: name of sf data frame\n\n-   returns:\n\n    -   v: vector with values (without a column name)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget.var <- function(vname,df) {\n  v <- df[vname] %>% \n    st_set_geometry(NULL)\n  v <- unname(v[,1])\n  return(v)\n}\n```\n:::\n\n\n\n#### A percentile mapping function\n\nNext, we will write a percentile mapping function by using the code chunk below.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npercentmap <- function(vnam, df, legtitle=NA, mtitle=\"Percentile Map\"){\n  percent <- c(0,.01,.1,.5,.9,.99,1)\n  var <- get.var(vnam, df)\n  bperc <- quantile(var, percent)\n  tm_shape(df) +\n  tm_polygons() +\n  tm_shape(df) +\n     tm_polygons(vnam,\n             title=legtitle,\n             breaks=bperc,\n             palette=\"Blues\",\n          labels=c(\"< 1%\", \"1% - 10%\", \"10% - 50%\", \"50% - 90%\", \"90% - 99%\", \"> 99%\"))  +\n  tm_borders() +\n  tm_layout(main.title = mtitle, \n            title.position = c(\"right\",\"bottom\"))\n}\n```\n:::\n\n\n\n#### Test drive the percentile mapping function\n\nTo run the function, type the code chunk as shown below.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npercentmap(\"total_wp\", NGA_wp)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex08.3_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\n\n### **Box map**\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = NGA_wp,\n       aes(x = \"\",\n           y = wp_nonfunctional)) +\n  geom_boxplot()\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex08.3_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n\n\n-   Displaying summary statistics on a choropleth map by using the basic principles of boxplot.\n\n-   To create a box map, a custom breaks specification will be used. However, there is a complication. The break points for the box map vary depending on whether lower or upper outliers are present.\n\n#### Creating the boxbreaks function\n\nThe code chunk below is an R function that creating break points for a box map.\n\n-   arguments:\n\n    -   v: vector with observations\n\n    -   mult: multiplier for IQR (default 1.5)\n\n-   returns:\n\n    -   bb: vector with 7 break points compute quartile and fences\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nboxbreaks <- function(v,mult=1.5) {\n  qv <- unname(quantile(v))\n  iqr <- qv[4] - qv[2]\n  upfence <- qv[4] + mult * iqr\n  lofence <- qv[2] - mult * iqr\n  # initialize break points vector\n  bb <- vector(mode=\"numeric\",length=7)\n  # logic for lower and upper fences\n  if (lofence < qv[1]) {  # no lower outliers\n    bb[1] <- lofence\n    bb[2] <- floor(qv[1])\n  } else {\n    bb[2] <- lofence\n    bb[1] <- qv[1]\n  }\n  if (upfence > qv[5]) { # no upper outliers\n    bb[7] <- upfence\n    bb[6] <- ceiling(qv[5])\n  } else {\n    bb[6] <- upfence\n    bb[7] <- qv[5]\n  }\n  bb[3:5] <- qv[2:4]\n  return(bb)\n}\n```\n:::\n\n\n\n#### Creating the get.var function\n\nThe code chunk below is an R function to extract a variable as a vector out of an sf data frame.\n\n-   arguments:\n\n    -   vname: variable name (as character, in quotes)\n\n    -   df: name of sf data frame\n\n-   returns:\n\n    -   v: vector with values (without a column name)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget.var <- function(vname,df) {\n  v <- df[vname] %>% st_set_geometry(NULL)\n  v <- unname(v[,1])\n  return(v)\n}\n```\n:::\n\n\n\n#### Test drive the newly created function\n\nLet’s test the newly created function\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvar <- get.var(\"wp_nonfunctional\", NGA_wp) \nboxbreaks(var)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -56.5   0.0  14.0  34.0  61.0 131.5 278.0\n```\n\n\n:::\n:::\n\n\n\n#### Boxmap function\n\nThe code chunk below is an R function to create a box map. - arguments: - vnam: variable name (as character, in quotes) - df: simple features polygon layer - legtitle: legend title - mtitle: map title - mult: multiplier for IQR - returns: - a tmap-element (plots a map)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nboxmap <- function(vnam, df, \n                   legtitle=NA,\n                   mtitle=\"Box Map\",\n                   mult=1.5){\n  var <- get.var(vnam,df)\n  bb <- boxbreaks(var)\n  tm_shape(df) +\n    tm_polygons() +\n  tm_shape(df) +\n     tm_fill(vnam,title=legtitle,\n             breaks=bb,\n             palette=\"Blues\",\n          labels = c(\"lower outlier\", \n                     \"< 25%\", \n                     \"25% - 50%\", \n                     \"50% - 75%\",\n                     \"> 75%\", \n                     \"upper outlier\"))  +\n  tm_borders() +\n  tm_layout(main.title = mtitle, \n            title.position = c(\"left\",\n                               \"top\"))\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\nboxmap(\"wp_nonfunctional\", NGA_wp)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex08.3_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "Hands-on_Ex08.3_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}